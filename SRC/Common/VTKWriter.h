#ifndef _VTKWRITER_H_
#define _VTKWRITER_H_

#include <vector>
#include <string>
#include <fstream>
#include <assertext.h>
#include <Log.h>
using namespace std;

namespace UTILITY{
  
  enum VTK_IO_TYPE{VTK_ASCII, VTK_BINARY};

  template<typename T,int N>
  struct VectorXdTmp{
  public:	
	int size()const{
	  return N;
	}
	T &operator [](int i){
	  assert_in(i,0,N-1);
	  return d[i];
	}
	const T &operator[](int i)const{
	  assert_in(i,0,N-1);
	  return d[i];
	}
  private:
    T d[N];
  };

  /**
   * @class VTKWriter auxiliary class for helping to write VTK files.
   * http://dunne.uni-hd.de/VisuSimple/documents/vtkfileformat.html
   */
  class VTKWriter{
	
  public:
	VTKWriter(const VTK_IO_TYPE t=VTK_BINARY):_iotype(t){
	  clear();
	}

	template<typename VECTOR>
	void addPoints(const VECTOR &points){
	  vector<VectorXdTmp<double,3> > vv;
	  convetVec2VV3d(points,vv);
	  addPoints(vv);
	}

	template<typename VECTOR_3D,typename ALLOCATOR>
	void addPoints(const vector<VECTOR_3D,ALLOCATOR> &points){
	  for (int i = 0; i < points.size(); ++i)
		_points << points[i][0] << " " << points[i][1]<< " " << points[i][2] << endl;
	  _nPoint += points.size();
	}

	template<typename VECTOR>
	void addTriangles(const VECTOR &faces){
	  vector<VectorXdTmp<int,3> > vv;
	  convetVec2VV3d(faces,vv);
	  addTriangles(vv);
	}

	template<typename VECTOR_3I,typename ALLOCATOR>
	void addTriangles(const vector<VECTOR_3I,ALLOCATOR> &faces){
	  
	  for (int i = 0; i < faces.size(); ++i)
		_cells<< 3 <<" "<< faces[i][0] << " " << faces[i][1]<< " " << faces[i][2] << endl;

	  for (int i = 0; i < faces.size(); ++i)
		_cellTypes << 5 << " ";

	  _nCells += faces.size();
	  _nCellIndexes += faces.size()*(3+1);
	}

	template<typename VECTOR>
	void addTets(const VECTOR &tets){
	  vector<VectorXdTmp<int,4> > vv;
	  convetVec2VV3d(tets,vv);
	  addTets(vv);
	}

	template<typename VECTOR_4I,typename ALLOCATOR>
	void addTets(const vector<VECTOR_4I,ALLOCATOR> &tets){

	  for (int i = 0; i < tets.size(); ++i)
		_cells<<4<<" "<<tets[i][0]<<" "<<tets[i][1]<<" "<<tets[i][2]<<" "<<tets[i][3]<<endl;

	  for (int i = 0; i < tets.size(); ++i)
		_cellTypes << 10 << " ";

	  _nCells += tets.size();
	  _nCellIndexes += tets.size()*(4+1);
	}

	bool write(const string filename)const{

	  ofstream outf(filename.c_str());
	  bool succ = outf.is_open();
	  if (succ){
		outf << head() << endl;
		outf << "\nPOINTS " << _nPoint<<" FLOAT" << endl;
		outf << _points.str() << endl;
		outf << "\nCELLS " << _nCells<<" " << _nCellIndexes << endl;
		outf << _cells.str() << endl;
		outf << "CELL_TYPES " << _nCells << endl;
		outf << _cellTypes.str() << endl;
	  }
	  outf.close();
	  return succ;
	}

	void clear(){
	  _nPoint = 0;
	  _nCells = 0;
	  _nCellIndexes = 0;
	  _points.clear();
	  _cellTypes.clear();
	  _cells.clear();
	}
	
  protected:
	string head()const{
	  const string s1="# vtk DataFile Version 3.1\n";
	  const string s2="generated by UTILITY::VTKWriter in the Utility library,author: simba\n";
	  const string s3=(VTK_BINARY==_iotype ? "BINARY\n":"ASCII\n");
	  const string s4="DATASET UNSTRUCTURED_GRID\n";
	  return s1+s2+s3+s4;
	}

	template<typename VECTOR,typename VECTOR3D>
	void convetVec2VV3d(const VECTOR &vec,VECTOR3D &vvec)const{

	  assert_eq(vec.size()%3,0);
	  vvec.resize(vec.size()/3);
	  for (size_t i = 0; i < vvec.size(); ++i){
		vvec[i][0] = vec[i*3+0];
		vvec[i][1] = vec[i*3+1];
		vvec[i][2] = vec[i*3+2];
	  }
	}
	
  private:
	const VTK_IO_TYPE _iotype;
	size_t _nPoint,_nCells,_nCellIndexes;
	ostringstream _points,_cells,_cellTypes;
  };
  
}//end of namespace

#endif /*_VTKWRITER_H_*/
